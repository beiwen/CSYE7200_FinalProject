package edu.neu.coe.CSYE7200_Team6_2018Spring.Ingest

import org.apache.spark.sql.{DataFrame, Dataset}
import org.apache.spark.sql.functions._
import org.apache.spark.ml.clustering.{KMeans, KMeansModel}
import org.apache.spark.ml.feature.{StandardScaler, VectorAssembler}

object Clustering {

  def clusteringByDist(ds: Dataset[Player]): Array[KMeansModel] = {

    def createDfWithFeature(ds: Dataset[Player]): DataFrame = {
      val vecAss = new VectorAssembler().setInputCols(Array("player_dist_ride", "player_dist_walk")).setOutputCol("unscaled_features")
      val assembledDf = vecAss.transform(ds).withColumn("id", monotonically_increasing_id())
      val scaler = new StandardScaler().setInputCol("unscaled_features").setOutputCol("features")
      val scalerModel = scaler.fit(assembledDf)
      val scaledDf = scalerModel.transform(assembledDf)
      scaledDf
    }

    def clusteringHelper(dsSeprated: Dataset[Player]): KMeansModel = {

      val k = dsSeprated.head().party_size match {
        // Numbers of clusters were generated by using elbow method within "determinFunction" below
        case 1 => 6
        case 2 => 4
        case 4 => 5
        case _ => 0
      }

      val kmeans = new KMeans().setK(k).setSeed(1L)
      val fitDf = createDfWithFeature(dsSeprated)
      fitDf.cache()
      val model = kmeans.fit(fitDf)
      model
    }

    val soloPlayers = ds.filter(d => d.party_size == 1).cache()
    val duoPlayers = ds.filter(d => d.party_size == 2).cache()
    val squadPlayers = ds.filter(d => d.party_size == 4).cache()

    val models = Array(soloPlayers, duoPlayers, squadPlayers).map(pd => clusteringHelper(pd))
    models
  }

  def clusteringByBattle(ds: Dataset[Player]): Array[KMeansModel] = ???

  def filterPlayers(ds: Dataset[Player]): Dataset[Player] = {
    val filterdPlayers = ds.filter(d => (d.player_dist_ride != 0 || d.player_dist_walk != 0) && d.player_survive_time <= 2400)
    filterdPlayers
  }

  def determinK(assembledDf: DataFrame): IndexedSeq[(Int, Double)] = {

    val clusters = Range(2, 10)
    def wssseList(asdf: DataFrame) = {
      clusters zip clusters.map(k => new KMeans().setK(k).setSeed(1L).fit(asdf).computeCost(asdf))
    }
    //Following return value is used to draw plot to find elbow point
    wssseList(assembledDf)
  }

}
